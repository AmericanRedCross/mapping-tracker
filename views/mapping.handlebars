
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css" />
<style>
#map{
  height: 450px;
}
svg {
  position: relative;
}

.leaflet-control-attribution a {
  color: #6d6e70 !important;
  cursor: pointer;
}
.clickable-icon{
  cursor: pointer;
}
.leaflet-control-attribution {
  font-size: x-small;
  color: #78787d;
}
.leaflet-control-attribution a {
  text-decoration: none;
  cursor: pointer;
  color: #6d6e70;
}
</style>

<header class="row header">
	<div class="col-md-12">
		<h1>Mapping dashboard</h1>
	</div>
</header>

<hr>

<div class="row">
	<div class="col-xs-12">
		<div id="map"></div>
	</div>
</div>

<hr>

<div id="calendar" style="width: 160px;"> </div>


<script src="js/colorbrewer.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js"></script>
<script>



var map = L.map('map').setView([0, 0], 2);
var mapFeatures = L.layerGroup().addTo(map);
var pointLayer = L.geoJson();
var mapBounds;


L.tileLayer('http://{s}.tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png', {
  attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);

function getGpxGeoJson(){
  $.ajax({
    type: 'GET',
    url: '/query/submissions-all',
    dataType: 'JSON'
  }).done(function(response){
  	mapData(response);
  });
}

function onEachFeature(feature, layer){
  var popupContent = "<b>type --- </b> " + feature.properties.type + "<br>";
  if(feature.properties.tags !== "undefined"){
    var tags = JSON.parse(feature.properties.tags);
    for(key in tags){
      popupContent += key + " = " + tags[key] + "<br>";
    }
  }
  layer.bindPopup(popupContent);
}

var geojsonMarkerOptions = {
    radius: 3,
    fillColor: "#ff7800",
    color: "#000",
    weight: 1,
    opacity: 1,
    fillOpacity: 0.8
};

function mapData(data){
  pointLayer = L.geoJson(data, {
    pointToLayer: function(feature,latlng){
				return L.circleMarker(latlng, geojsonMarkerOptions);
		},
    onEachFeature: onEachFeature
  }).addTo(mapFeatures)
  mapBounds = pointLayer.getBounds()
  map.fitBounds(mapBounds);
}

getGpxGeoJson();

var calendarData = [];

function getCalendarData(){
  url = window.location.origin + "/query/submissions-date-count";
  $.get(url, function(response){
    $.each(response, function(i, day){
      day.today = day.today.slice(0,10);
    });
    calendarData = response;
    drawCalendar()
  });
}


function drawCalendar(){

  var calendarRows = function(month){
    //expects the month floor e.g. `Tue Mar 01 2016 00:00:00 GMT-0500 (EST)`
    return d3.time.weeks(d3.time.week.floor(month), d3.time.month.offset(month,1)).length
  }

  var minDate = d3.min(calendarData, function(d) { return new Date(d.today) })
  // var maxDate = new Date("2016-03-28")
  var maxDate = d3.max(calendarData, function(d) { return new Date(d.today) })


 var cellMargin = 2,
     cellSize = 20;

 var day = d3.time.format("%w"),
     week = d3.time.format("%U"),
     percent = d3.format(".1%"),
     format = d3.time.format("%Y-%m-%d"),
     titleFormat = d3.time.format.utc("%d %b");
     monthName = d3.time.format("%B"),
     months= d3.time.month.range(d3.time.month.floor(minDate), maxDate);

 var svg = d3.select("#calendar").selectAll("svg")
     .data(months)
     .enter().append("svg")
       .attr("width", (cellSize * 7) + (cellMargin * 8))
       .attr("height", function(d) {
         console.log(calendarRows(d))
          var rows = calendarRows(d);
          return (cellSize * rows) + (cellMargin * (rows + 1))
        })
       .attr("class", "RdYlGn")
     .append("g")

 var rect = svg.selectAll("rect.day")
     .data(function(d, i) { return d3.time.days(d, new Date(d.getFullYear(), d.getMonth()+1, 1)); })
     .enter().append("rect")
       .attr("class", "day")
       .attr("width", cellSize)
       .attr("height", cellSize)
       .attr("rx", 3)
       .attr("ry", 3)
       .attr("fill", '#d0d0d0')
       .attr("x", function(d) { return (day(d) * cellSize) + (day(d) * cellMargin) + cellMargin; })
       .attr("y", function(d) { return ((week(d) - week(new Date(d.getFullYear(),d.getMonth(),1))) * cellSize) + ((week(d) - week(new Date(d.getFullYear(),d.getMonth(),1))) * cellMargin) + cellMargin ; })
       .on("mouseover", function(d) {
         d3.select(this).style("stroke", "#6d6E70").style("stroke-width", 2)
       })
       .on("mouseout", function(d) {
         d3.select(this).style("stroke", 'none').style("stroke-width", 0)
       })
      .datum(format);

 rect.append("title")
    .text(function(d) { return titleFormat(new Date(d)); });

  var data = d3.nest()
    .key(function(d) { return d.today; })
    .rollup(function(leaves) { return d3.sum(leaves, function(d){ return parseInt(d.count); }); })
    .map(calendarData);


    var color = d3.scale.quantize()
      .domain([d3.min(calendarData, function(d) { return parseInt(d.count) }), d3.max(calendarData, function(d) { return parseInt(d.count) })])
      .range(["#fc9272","#fb6a4a","#ef3b2c","#cb181d","#a50f15","#67000d"]);
      // Every ColorBrewer Scale
      // http://bl.ocks.org/mbostock/raw/5577023/

  rect.filter(function(d) { return d in data; })
      .style("fill", function(d) { return color(data[d]) })
    .select("title")
      .text(function(d) { return titleFormat(new Date(d)) + ": " + data[d]; });

}

getCalendarData();

function getHexData(){
  $.ajax({
    type: 'POST',
    // data: {'file': filename},
    url: '/query/hex',
    dataType: 'JSON'
  }).done(function(response){
    console.log("got hex data")
    mapHex(response)
  });
}


var svg = d3.select(map.getPanes().overlayPane).append("svg"),
    hexGroup = svg.append("g").attr("class", "leaflet-zoom-hide");

function mapHex(fc){

  var color = d3.scale.quantize()
    .domain([d3.min(fc.features, function(d) { return d.properties.total }), d3.max(fc.features, function(d) { return d.properties.total })])
    .range(["#c994c7","#df65b0","#e7298a","#ce1256","#980043","#67001f"]);

  function projectPoint(x, y) {
    var point = map.latLngToLayerPoint(new L.LatLng(y, x));
    this.stream.point(point.x, point.y);
  }

  var transform = d3.geo.transform({point: projectPoint}),
      path = d3.geo.path().projection(transform);

  var feature = hexGroup.selectAll("path")
    .data(fc.features)
    .enter().append("path");

  map.on("viewreset", reset);
  reset();

  function reset() {
      var bounds = path.bounds(fc),
          topLeft = bounds[0],
          bottomRight = bounds[1];

      svg .attr("width", bottomRight[0] - topLeft[0])
          .attr("height", bottomRight[1] - topLeft[1])
          .style("left", topLeft[0] + "px")
          .style("top", topLeft[1] + "px");

      hexGroup   .attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");

      feature.attr("d", path)
        .style("fill", function(d){
          return color(d.properties.total)
        })
        .style("fill-opacity", 0.45)
    }

}

getHexData()

</script>
